# Blue-Green Deployment Azure Infrastructure

Introduction

This code for deploying an Azure infrastructure that supports blue-green deployment using Terraform. The code defines various Azure resources, including resource groups, virtual networks, subnets, public IP addresses, application gateways, managed identities, and AKS clusters. The infrastructure is designed to enable blue-green deployment for application workloads.

![image](https://github.com/walissonscd/azure-blue-green-deployment/assets/136257825/d17ce442-ecaa-46c9-ad11-a8cd765238c0)



Prerequisites

Before running the code, ensure that the following prerequisites are met:

Azure CLI is installed and configured.
Terraform is installed on the local machine.
Azure credentials are available and authenticated.

Code Overview

The code is divided into several sections, each responsible for creating a specific resource or module. Here's an overview of each section:

Random Pet Resources

The random_pet resources generate random names to be used for resource and component naming. These names are unique identifiers generated by Terraform.

Resource Group

The azurerm_resource_group resource creates an Azure resource group. The resource group is used to logically group resources that belong to the blue-green deployment. The name is generated using the random pet resource and a prefix. The resource group is deployed with the specified name and the location defined in the local.location variable.

Virtual Network

The azurerm_virtual_network resource creates an Azure virtual network within the resource group. The virtual network provides isolation for the deployed resources. The name is generated using the random pet resource and a prefix. It depends on the resource group and is associated with the address space specified in the local.vnet_address_space variable.
Subnets

Three instances of the subnet module are created (subnet1, subnet2, subnet3), each responsible for creating a subnet within the virtual network. The subnets define smaller address ranges within the virtual network. The modules depend on the resource group, virtual network, and other necessary variables. Each subnet module is associated with a specific IP address range defined in the subnet_prefixes variable.

Public IP Address

The public_ip module creates a public IP address for the application gateway. The public IP address allows external access to the deployed resources. It depends on the resource group and is associated with a name generated using the random pet resource and a prefix.

Application Gateway

The application_gateway module creates an Azure Application Gateway within the resource group. The application gateway acts as a load balancer and reverse proxy for the application workloads. It depends on the subnet and public IP address modules. The application gateway is associated with a name generated using the random pet resource and a prefix. It also requires the subnet and public IP address IDs as inputs.

Managed Identities

The azurerm_user_assigned_identity resource creates a user-assigned managed identity. The managed identity is used for authentication and authorization purposes within the deployed resources. It depends on the resource group and is associated with a name generated using the random pet resource and a prefix.

![image](https://github.com/walissonscd/azure-blue-green-deployment/assets/136257825/8f7a12f0-2059-4ebf-8513-6e3054f3be58)


AKS Clusters

Two instances of the aks_cluster module are created (aks_cluster1, aks_cluster2), each responsible for creating an Azure Kubernetes Service (AKS) cluster. The AKS clusters host the application workloads. The modules depend on the resource group, managed identity, subnet, and application gateway. Each AKS cluster is associated with a name generated using the random pet resource and a prefix. They also require the necessary input variables, such as cluster name, managed identity ID, gateway ID, and subnet ID.

Kubernetes Resources

The code also includes Kubernetes resources for deploying application workloads. These resources are specific to the blue deployment.
Kubernetes Pod

The kubernetes_pod resource defines a Kubernetes pod within the blue environment. The pod runs an Nginx container and configures it to display a specific message. The pod is associated with a name and labels.
Kubernetes Service

The kubernetes_service resource defines a Kubernetes service within the blue environment. The service exposes the Nginx container within the pod. It is associated with a name and a selector.
Kubernetes Ingress

The kubernetes_ingress_v1 resource defines a Kubernetes ingress within the blue environment. The ingress provides external access to the Nginx container through the application gateway. It depends on the green ingress and is associated with a name, annotations, and a rule that maps the host to the service.


Role Assignments

The azurerm_role_assignment resources assign roles to the AKS cluster and managed identity. Two role assignments are made for the application gateway and AKS clusters, respectively. The assignments grant the specified roles (Contributor and Network Contributor) to the associated resources.

![image](https://github.com/walissonscd/azure-blue-green-deployment/assets/136257825/94c76eb8-f2bc-4f11-9732-403eabb603b2)


Outputs

The output section defines an output variable to display the public IP address of the created resource. The output provides the public IP address of the application gateway, which can be useful for accessing the deployed resources.

Usage

To deploy the blue-green deployment infrastructure using this code, follow these steps:

   Install and configure Azure CLI on your machine.
   Install Terraform on your machine.
   Set up your Azure credentials and authenticate with Azure CLI.
   Navigate to the directory containing the Terraform code.
   Run the following command to initialize the Terraform environment:

    terraform init

Review and modify the input variables in the code as needed.
Run the following command to preview the changes that Terraform will make:

    terraform plan

If the plan looks good, run the following command to apply the changes and create the infrastructure:

    terraform apply

Confirm the deployment by typing yes when prompted.
Wait for the deployment to complete.
